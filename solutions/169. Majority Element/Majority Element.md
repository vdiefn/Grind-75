## 題目說明

## 解題思路
### 方法一、不符合題目要求
1. 使用reduce計算每一個數字出現的次數
2. 使用for迴圈找出出現次數最多的那個數字
3. 此方法的空間複雜度為O(n)，不符合題目要求的O(1)
---
### 優化方法一
1. 修改迴圈邏輯，讓程式碼在找到答案的那一刻就停下來
2. 使用 Map 物件來避開字串轉換的陷阱，並保持資料原始型別
### 方法二、摩爾投票法（Boyer-Moore Voting Algorithm）
1. 空間複雜度會看使用的記憶體數量，因此方法僅會建立2個變數(candidate, counts)來記錄，故空間複雜度為O(1)
2. 但因為還是需要遍歷一次整個陣列，故時間複雜度仍為O(n)
3. 這個方法的概念為在有一個candidate的情況下，如果下一個candidate和現有candidate相同，則counts數量++。若目前candidate和下一個candidate不一樣，則counts--，當counts為零的時候，則代表現在遍歷到的對象就是candidate
4. 這是簡易版的算法，此算法的前提為此陣列中要有一個眾數
